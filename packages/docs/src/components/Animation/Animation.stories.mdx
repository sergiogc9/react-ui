import { ArgsTable, Meta, Story, Canvas } from 'storybook/utils/components';
import { getFixedStoryParams, getPlaygroundStoryParams } from 'storybook/parameters';
import AnimationDecorator, { AnimationListDecorator } from 'storybook/decorators/Animation';
import Animation from 'components/Animation';
import { AnimatedButton, ButtonAnimate, CustomAnimatedButton, CustomAnimation } from './Animation';

<Meta title="Components/Animation" component={Animation.Animate} />

<Story
	name="playground"
	args={{ animateAtMount: true, isVisible: true }}
	decorators={[AnimationDecorator]}
	parameters={getPlaygroundStoryParams()}
>
	{args => <Animation.FadeIn {...args}>Awesome title</Animation.FadeIn>}
</Story>

<Story name="playground multiple" args={{}} decorators={[AnimationDecorator]} parameters={getPlaygroundStoryParams()}>
	{args => (
		<Animation.Animate
			{...args}
			animation={[Animation.FadeInAnimation, CustomAnimation, Animation.FadeOutAnimation, Animation.FadeInAnimation]}
			duration={['2s', '1s', '1s', '2s']}
		>
			This library rocks!
		</Animation.Animate>
	)}
</Story>

# Animation

Animation is set of components and utils to help using animations in our styled-components based components. The main features are:

- You can use predefined animations or create custom ones.
- You can use these animations as a wrapper div or convert an existing component into an animation component.
- You can join different animations to be used one after each other, using the `Animate` component.
- You can start and stop animations using the `isEnabled` prop.
- You can show or hide the component using the `isVisible` prop. This is useful when you want to use the reverse animation before unmounting the component.
- Use different animation config for show and hide animations. Each animation prop has its own exit prop (e.g. `animationExit` or `durationExit`).
- You can avoid performing the animation at mount using the `animateAtMount` prop.

ℹ️ This components goal is to provide a easy way to use `animations` with `keyframes`. Sometimes it's easier to simply use `transitions` to achieve the same result.

## Start and stop the animation

Both BaseAnimation and Animate component comes with a `isEnabled` prop that tells the component to perform or not the animation. The expected behavior is:

- If false, no animation is performed.
- If true, the animation is started at mount.
- When changing to a falsy value, the animation is stopped and reset to the beggining.
- When changing to a truthy value, the animation is started again from the beggining.

ℹ️ This component stories have a "Restart animation" button that simply sets a false value and then it sets a true value after some milliseconds.

## Mounting and unmounting the component

Sometimes you want to performe a reverse animation when you want to remove the component (e.g. perform a FadeOut component if is shown with a FadeIn).

Using the `isVisible` prop you can tell to both BaseAnimation and Animate components when the component should be rendered or not.

To specify the remove animation, use the animation config props with the `Exit` suffix. If not using these props, the component will perform the animation or animations in the reverse direction. Once the exit animation finishes, the component is unmount.

The `isVisible` prop behavior is the following:

- If false, no component is rendered.
- If true, the component is rendered and the animation is started if `isEnabled` is not false.
- When changing to a falsy value, the component performs the exit animation(s) or the animation(s) in the reverse direction. Once they finish, the component is unmounted from the DOM.
- When changing to a truthy value, the component is rendered and the animation is started if `isEnabled` is not false.

ℹ️ You can test this behavior using the playground stories.

## BaseAnimation

The BaseAnimation is the base component used to create the animated components. It basically adds some css animation properties as component props (see API below).

### Pre-defined animations

This library includes some pre-defined animation components that uses the BaseAnimation inside. An example is the `FadeIn` component.

These pre-defined animations can be used as a component and, by default, they will use a div wrapper to perform the animation.
All the pre-defined components includes an animation `keyframes` object if you want to create a custom component using the pre-defined animation (see custom components below).

An example using FadeIn:

<Canvas>
	<Story
		name="fade-in"
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `<Animation.FadeIn duration="2s">This library rocks!</Animation.FadeIn>`
				}
			}
		}}
	>
		{args => (
			<Animation.FadeIn {...args} duration="2s">
				This library rocks!
			</Animation.FadeIn>
		)}
	</Story>
</Canvas>

You can try all available pre-defined animations selecting the story in the left sidebar.

<Story
	name="fade-out"
	decorators={[AnimationDecorator]}
	parameters={{
		...getFixedStoryParams(),
		docs: { disable: true }
	}}
>
	{args => <Animation.FadeOut {...args}>This library rocks!</Animation.FadeOut>}
</Story>

<Story
	name="slide-down"
	decorators={[AnimationDecorator]}
	parameters={{
		...getFixedStoryParams(),
		docs: { disable: true }
	}}
>
	{args => <Animation.SlideDown {...args}>This library rocks!</Animation.SlideDown>}
</Story>

<Story
	name="slide-up"
	decorators={[AnimationDecorator]}
	parameters={{
		...getFixedStoryParams(),
		docs: { disable: true }
	}}
>
	{args => <Animation.SlideUp {...args}>This library rocks!</Animation.SlideUp>}
</Story>

### Overriding an existing component

The example above uses a wrapper div (i.e. a Box component). If you don't want this Box wrapper, you can create custom animation components using the HOC `withBaseAnimation`.

The returned component by the HOC will have all behaviors and props from `BaseAnimation`.

An example with the Button component and the FadeIn animation:

<Canvas>
	<Story
		name="with custom component"
		decorators={[AnimationDecorator]}
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { Animation, Button } from '@sergiogc9/react-ui';
const AnimatedButton = Animation.withBaseAnimation(
  Button,
  Animation.FadeInAnimation
);
<AnimatedButton duration="2s">This library rocks!</AnimatedButton>`
				}
			}
		}}
	>
		{args => (
			<AnimatedButton {...args} duration="2s">
				This library rocks!
			</AnimatedButton>
		)}
	</Story>
</Canvas>

### Custom animations

You can create custom animations passing a keyframes object to the `withBaseAnimation`.

An example with a custom animation and the Button Component:

<Canvas>
	<Story
		name="with custom animation"
		decorators={[AnimationDecorator]}
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { keyframes } from 'styled-components';
import { Animation, Button } from '@sergiogc9/react-ui';
const CustomAnimation = keyframes\`
  from {
    transform: scale(.5) translateX(0);
  }
  50% {
    transform: scale(1.5) translateX(75px);
  }
  to {
    transform: scale(1) translateX(150px);
  }
\`;
const CustomAnimatedButton = Animation.withBaseAnimation(
  Button,
  CustomAnimation
);
<CustomAnimatedButton duration="2s">This library rocks!</CustomAnimatedButton>`
				}
			}
		}}
	>
		{args => (
			<CustomAnimatedButton {...args} duration="2s">
				This library rocks!
			</CustomAnimatedButton>
		)}
	</Story>
</Canvas>

## Animate

The Animate component lets to use more than one animation, one after each other. It has the same props as `BaseAnimation` but in an array format, where each index on it represents a unique animation.

For example, following the examples above, we can use the FadeIn and FadeOut pre-defined animations together with our custom animation:

<Canvas>
	<Story
		name="with multiple animations"
		decorators={[AnimationDecorator]}
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { keyframes } from 'styled-components';
import { Animation, Button } from '@sergiogc9/react-ui';
const CustomAnimation = keyframes\`
  from {
    transform: scale(.5) translateX(0);
  }
  50% {
    transform: scale(1.5) translateX(75px);
  }
  to {
    transform: scale(1) translateX(150px);
  }
\`;
<Animation.Animate
  animation={[
    CustomAnimation,
    CustomAnimation,
    Animation.FadeOutAnimation,
    Animation.FadeInAnimation
  ]}
  direction={['normal', 'reverse', 'normal', 'normal']}
  duration={['1s', '2000ms', '2.5s', '2s']}
>
  This library rocks!
</Animation.Animate>`
				}
			}
		}}
	>
		{args => (
			<Animation.Animate
				{...args}
				animation={[CustomAnimation, CustomAnimation, Animation.FadeOutAnimation, Animation.FadeInAnimation]}
				direction={['normal', 'reverse', 'normal', 'normal']}
				duration={['1s', '2000ms', '2.5s', '2s']}
			>
				This library rocks!
			</Animation.Animate>
		)}
	</Story>
</Canvas>

### Overriding custom components

Euqal than with `BaseAnimation`, you can use the `withAnimate` HOC to convert an existing component into an `Animate` component, adding to it the behavior and props from Animate.

An example using the Button component:

<Canvas>
	<Story
		name="existing component with multiple animations"
		decorators={[AnimationDecorator]}
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { keyframes } from 'styled-components';
import { Animation, Button } from '@sergiogc9/react-ui';
const CustomAnimation = keyframes\`
  from {
    transform: scale(.5) translateX(0);
  }
  50% {
    transform: scale(1.5) translateX(75px);
  }
  to {
    transform: scale(1) translateX(150px);
  }
\`;
const ButtonAnimate = Animation.withAnimate(Button);
<ButtonAnimate
  animation={[
    CustomAnimation,
    CustomAnimation,
    Animation.FadeOutAnimation,
    Animation.FadeInAnimation
  ]}
  direction={['normal', 'reverse', 'normal', 'normal']}
  duration={['1s', '2000ms', '2.5s', '2s']}
>
  This library rocks!
</ButtonAnimate>`
				}
			}
		}}
	>
		{args => (
			<ButtonAnimate
				{...args}
				animation={[CustomAnimation, CustomAnimation, Animation.FadeOutAnimation, Animation.FadeInAnimation]}
				direction={['normal', 'reverse', 'normal', 'normal']}
				duration={['1s', '2000ms', '2.5s', '2s']}
			>
				This library rocks!
			</ButtonAnimate>
		)}
	</Story>
</Canvas>

## Animation List

Sometimes you want to animate elements inside a dynamic list (e.g. a table, accordeons, etc.). For these use cases, you can use the `Animation.List` component. The main features are:

- Animates its direct childs managing the `isVibile` prop for each child.
- Detects new elements in the list and animates them if needed.
- Detects removed elements keeping them into the DOM until the animation ends.
- Animate children provided at mount or not using the `animateAtMount` prop.

In order to make this component to work fine, there are some rules to follow:

- The children must be an array of `Animate` or `BaseAnimation` components. Custom components created with `withAnimate` or `withBaseAnimation` are also valid.
- As React guidelines says, each children must have an unique `key` prop. If not, strange behaviors can occur because the component will use index based keys.
- Don't specify the `isVisible` prop manually to children components. This is handled by the List component.

<Canvas>
	<Story
		name="animation list"
		decorators={[AnimationListDecorator]}
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { keyframes } from 'styled-components';
import { Animation, Button } from '@sergiogc9/react-ui';
const appearAnimation = keyframes\`
  from {
	  max-height:0;
	  opacity: 0;
  }
  to {
	  max-height: 50px;
	  opacity: 1;
  }
\`;
<Animation.List>
  {items.map((item) => (
        <Animation.BaseAnimation
          animation={appearAnimation}
          key={item.key}
        >
          <Content color="primary.500">{item.name}</Content>
        </Animation.BaseAnimation>
      ))}
</Animation.List>`
				}
			}
		}}
	>
		{args => <Animation.List {...args} />}
	</Story>
</Canvas>

# BaseAnimation API

<ArgsTable of={Animation.BaseAnimation} />

# Animate API

<ArgsTable of={Animation.Animate} />

# Animate.List API

<ArgsTable of={Animation.List} />
