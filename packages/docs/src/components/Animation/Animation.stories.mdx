import { ArgsTable, Meta, Story, Canvas } from 'storybook/utils/components';
import { getFixedStoryParams, getPlaygroundStoryParams } from 'storybook/parameters';
import AnimationDecorator from 'storybook/decorators/Animation';
import Animation from 'components/Animation';
import { AnimatedButton, ButtonAnimate, CustomAnimatedButton, CustomAnimation } from './Animation';

<Meta title="Components/Animation" component={Animation.Animate} decorators={[AnimationDecorator]} />

<Story name="playground" args={{}} parameters={getPlaygroundStoryParams()}>
	{args => <Animation.FadeIn {...args}>Awesome title</Animation.FadeIn>}
</Story>

<Story name="playground multiple" args={{}} parameters={getPlaygroundStoryParams()}>
	{args => (
		<Animation.Animate
			{...args}
			animation={[Animation.FadeInAnimation, CustomAnimation, Animation.FadeOutAnimation, Animation.FadeInAnimation]}
			duration={['2s', '1s', '1s', '2s']}
		>
			This library rocks!
		</Animation.Animate>
	)}
</Story>

# Animation

Animation is set of components and utils to help using animations in our styled-components based components. The main features are:

- You can use predefined animations or create custom ones.
- You can use these animations as a wrapper div or convert an existing component into an animation component.
- You can join different animations to be used one after each other, using the `Animate` component.
- You can start and stop animations using the `isEnabled` prop.
- You can show or hide the component using the `isVisible` prop. This is useful when you want to use the reverse animation before unmounting the component.

ℹ️ This components goal is to provide a easy way to use `animations` with `keyframes`. Sometimes it's easier to simply use `transitions` to achieve the same result.

## BaseAnimation

The BaseAnimation is the base component used to create the animated components. It basically adds some css animation properties as component props (see API below).

### Pre-defined animations

This library includes some pre-defined animation components that uses the BaseAnimation inside. An example is the `FadeIn` component.

These pre-defined animations can be used as a component and, by default, they will use a div wrapper to perform the animation.
All the pre-defined components includes an animation `keyframes` object if you want to create a custom component using the pre-defined animation (see custom components below).

An example using FadeIn:

<Canvas>
	<Story
		name="fade-in"
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `<Animation.FadeIn duration="2s">This library rocks!</Animation.FadeIn>`
				}
			}
		}}
	>
		{args => (
			<Animation.FadeIn {...args} duration="2s">
				This library rocks!
			</Animation.FadeIn>
		)}
	</Story>
</Canvas>

You can try all available pre-defined animations selecting the story in the left sidebar.

<Story
	name="fade-out"
	parameters={{
		...getFixedStoryParams(),
		docs: { disable: true }
	}}
>
	{args => <Animation.FadeOut {...args}>This library rocks!</Animation.FadeOut>}
</Story>

### Overriding an existing component

The example above uses a wrapper div (i.e. a Box component). If you don't want this Box wrapper, you can create custom animation components using the HOC `withBaseAnimation`.

The returned component by the HOC will have all behaviors and props from `BaseAnimation`.

An example with the Button component and the FadeIn animation:

<Canvas>
	<Story
		name="with custom cumponent"
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { Animation, Button } from '@sergiogc9/react-ui';
const AnimatedButton = Animation.withBaseAnimation(
  Button,
  Animation.FadeInAnimation
);
<AnimatedButton duration="2s">This library rocks!</AnimatedButton>`
				}
			}
		}}
	>
		{args => (
			<AnimatedButton {...args} duration="2s">
				This library rocks!
			</AnimatedButton>
		)}
	</Story>
</Canvas>

### Custom animations

You can create custom animations passing a keyframes object to the `withBaseAnimation`.

An example with a custom animation and the Button Component:

<Canvas>
	<Story
		name="with custom animation"
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { keyframes } from 'styled-components';
import { Animation, Button } from '@sergiogc9/react-ui';
const CustomAnimation = keyframes\`
  from {
    transform: scale(.5) translateX(0);
  }
  50% {
    transform: scale(1.5) translateX(75px);
  }
  to {
    transform: scale(1) translateX(150px);
  }
\`;
const CustomAnimatedButton = Animation.withBaseAnimation(
  Button,
  CustomAnimation
);
<CustomAnimatedButton duration="2s">This library rocks!</CustomAnimatedButton>`
				}
			}
		}}
	>
		{args => (
			<CustomAnimatedButton {...args} duration="2s">
				This library rocks!
			</CustomAnimatedButton>
		)}
	</Story>
</Canvas>

## Animate

The Animate component lets to use more than one animation, one after each other. It has the same props as `BaseAnimation` but in an array format, where each index on it represents a unique animation.

For example, following the examples above, we can use the FadeIn and FadeOut pre-defined animations together with our custom animation:

<Canvas>
	<Story
		name="with multiple animations"
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { keyframes } from 'styled-components';
import { Animation, Button } from '@sergiogc9/react-ui';
const CustomAnimation = keyframes\`
  from {
    transform: scale(.5) translateX(0);
  }
  50% {
    transform: scale(1.5) translateX(75px);
  }
  to {
    transform: scale(1) translateX(150px);
  }
\`;
<Animation.Animate
  animation={[
    CustomAnimation,
    CustomAnimation,
    Animation.FadeOutAnimation,
    Animation.FadeInAnimation
  ]}
  direction={['normal', 'reverse', 'normal', 'normal']}
  duration={['1s', '2000ms', '2.5s', '2s']}
>
  This library rocks!
</Animation.Animate>`
				}
			}
		}}
	>
		{args => (
			<Animation.Animate
				{...args}
				animation={[CustomAnimation, CustomAnimation, Animation.FadeOutAnimation, Animation.FadeInAnimation]}
				direction={['normal', 'reverse', 'normal', 'normal']}
				duration={['1s', '2000ms', '2.5s', '2s']}
			>
				This library rocks!
			</Animation.Animate>
		)}
	</Story>
</Canvas>

### Overriding custom components

Euqal than with `BaseAnimation`, you can use the `withAnimate` HOC to convert an existing component into an `Animate` component, adding to it the behavior and props from Animate.

An example using the Button component:

<Canvas>
	<Story
		name="existing component with multiple animations"
		parameters={{
			...getFixedStoryParams(),
			docs: {
				source: {
					code: `
import { keyframes } from 'styled-components';
import { Animation, Button } from '@sergiogc9/react-ui';
const CustomAnimation = keyframes\`
  from {
    transform: scale(.5) translateX(0);
  }
  50% {
    transform: scale(1.5) translateX(75px);
  }
  to {
    transform: scale(1) translateX(150px);
  }
\`;
const ButtonAnimate = Animation.withAnimate(Button);
<ButtonAnimate
  animation={[
    CustomAnimation,
    CustomAnimation,
    Animation.FadeOutAnimation,
    Animation.FadeInAnimation
  ]}
  direction={['normal', 'reverse', 'normal', 'normal']}
  duration={['1s', '2000ms', '2.5s', '2s']}
>
  This library rocks!
</ButtonAnimate>`
				}
			}
		}}
	>
		{args => (
			<ButtonAnimate
				{...args}
				animation={[CustomAnimation, CustomAnimation, Animation.FadeOutAnimation, Animation.FadeInAnimation]}
				direction={['normal', 'reverse', 'normal', 'normal']}
				duration={['1s', '2000ms', '2.5s', '2s']}
			>
				This library rocks!
			</ButtonAnimate>
		)}
	</Story>
</Canvas>

## Start and stop the animation

Both BaseAnimation and Animate component comes with a `isEnabled` prop that tells the component to perform or not the animation. The expected behavior is:

- If false, no animation is performed.
- If true, the animation is started at mount.
- When changing to a falsy value, the animation is stopped and reset to the beggining.
- When changing to a truthy value, the animation is started again from the beggining.

ℹ️ This component stories have a "Restart animation" button that simply sets a false value and then it sets a true value after some milliseconds.

## Mounting and unmounting the component

Sometimes you want to performe a reverse animation when you want to remove the component (e.g. perform a FadeOut component if is shown with a FadeIn).

Using the `isVisible` prop you can tell to both BaseAnimation and Animate components when the component should be rendered or not. If using this prop, the component will perform the animation or animations in the reverse direction and, when they all finish, unmount the component.

- If false, no component is rendered.
- If true, the component is rendered and the animation is started if `isEnabled` is not false.
- When changing to a falsy value, the component performs the animation(s) in the reverse direction. Once they finish, the component is unmounted from the DOM.
- When changing to a truthy value, the component is rendered and the animation is started if `isEnabled` is not false.

ℹ️ You can test this behavior using the playground stories.

# BaseAnimation API

<ArgsTable of={Animation.BaseAnimation} />

# Animate API

<ArgsTable of={Animation.Animate} />
